<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Christmas - Final Clean</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000000;
        font-family: "Segoe UI", sans-serif;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
      }

      #ui-layer {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 100;
      }
      .guide {
        color: rgba(255, 255, 255, 0.6);
        font-size: 13px;
        margin-bottom: 20px;
        text-shadow: 0 2px 4px black;
      }
      button {
        pointer-events: auto;
        cursor: pointer;
        background: linear-gradient(to bottom, #d32f2f, #8b0000);
        color: #fff;
        border: 2px solid #ffd700;
        padding: 15px 50px;
        border-radius: 30px;
        font-weight: 800;
        font-size: 16px;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.6);
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      #camera-preview {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 120px;
        height: 90px;
        border: 2px solid rgba(255, 0, 0, 0.5);
        transform: scaleX(-1);
        opacity: 0.6;
        border-radius: 8px;
      }

      #copyright {
        position: absolute;
        bottom: 10px;
        right: 15px;
        color: rgba(255, 255, 255, 0.3);
        font-size: 12px;
        z-index: 100;
        font-family: sans-serif;
        pointer-events: none;
        font-style: italic;
      }

      #error-log {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        color: red;
        background: rgba(0, 0, 0, 0.8);
        z-index: 999;
        padding: 10px;
      }
    </style>
  </head>

  <body>
    <div id="error-log"></div>

    <div id="ui-layer">
      <div class="guide">
        üñê <b>Open:</b> Explode &nbsp;|&nbsp; ü´∂ <b>Heart:</b> Love &nbsp;|&nbsp;
        ‚úä <b>Fist:</b> Tree
      </div>
      <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <div id="copyright">¬© by vandiep</div>

    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      // ==========================================
      // 1. RESOURCES CONFIG Vandiep
      // ==========================================
      const MUSIC_URL = "./audio.mp3";
      let bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 1.0;

      const loader = new THREE.TextureLoader();
      const photoFiles = [
        "./image1.jpeg",
        "./image2.jpeg",
        "./image3.jpeg",
        "./image4.jpeg",
        "./image5.jpeg",
      ];
      const photoTextures = [];
      photoFiles.forEach((f, i) => (photoTextures[i] = loader.load(f)));

      function createCustomTexture(type) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        const cx = 64,
          cy = 64;

        if (type === "gold_glow") {
          ctx.clearRect(0, 0, 128, 128);

          const grd = ctx.createLinearGradient(0, 0, 128, 128);
          grd.addColorStop(0.0, "#FFFDE7");
          grd.addColorStop(0.18, "#FFD700");
          grd.addColorStop(0.35, "#B8860B");
          grd.addColorStop(0.5, "#FFF8DC"); // specular line
          grd.addColorStop(0.65, "#C9A227");
          grd.addColorStop(1.0, "#5E4B00");

          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(64, 64, 52, 0, Math.PI * 2);
          ctx.fill();

          // highlight s·∫Øc
          ctx.strokeStyle = "rgba(255,255,255,0.9)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(48, 46, 30, -0.2, Math.PI * 0.8);
          ctx.stroke();
        }
        if (type === "red_light") {
          ctx.clearRect(0, 0, 128, 128);

          const grd = ctx.createLinearGradient(0, 0, 128, 128);
          grd.addColorStop(0.0, "#FFE5E5");
          grd.addColorStop(0.25, "#FF3D3D");
          grd.addColorStop(0.45, "#8E0000");
          grd.addColorStop(0.55, "#FFD6D6"); // specular
          grd.addColorStop(0.75, "#B71C1C");
          grd.addColorStop(1.0, "#4A0000");

          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(64, 64, 52, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "rgba(255,255,255,0.85)";
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.arc(50, 48, 28, -0.3, Math.PI * 0.7);
          ctx.stroke();
        } else if (type === "gift_red") {
          ctx.fillStyle = "#D32F2F";
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = "#FFD700";
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
          ctx.strokeStyle = "rgba(0,0,0,0.3)";
          ctx.lineWidth = 2;
          ctx.strokeRect(20, 20, 88, 88);
        } else if (type === "white_glow") {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.35, "rgba(255,255,255,0.75)");
          grd.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === "green_glow") {
          ctx.clearRect(0, 0, 128, 128);

          const x = 36;
          const y = 36;
          const w = 56;
          const h = 56;

          // --- MASK VU√îNG ---
          ctx.save();
          ctx.beginPath();
          ctx.rect(x, y, w, h);
          ctx.clip();

          // --- GLOW B√äN TRONG VU√îNG ---
          const grd = ctx.createRadialGradient(
            x + w * 0.35,
            y + h * 0.3,
            6,
            cx,
            cy,
            42
          );
          grd.addColorStop(0, "#FFFFFF");
          grd.addColorStop(0.3, "#A5D6A7");
          grd.addColorStop(0.6, "#4CAF50");
          grd.addColorStop(1, "#1B5E20");

          ctx.fillStyle = grd;
          ctx.fillRect(x, y, w, h);
          ctx.restore();

          // --- CORE VU√îNG ---
          ctx.fillStyle = "#2E7D32";
          ctx.fillRect(x + 6, y + 6, w - 12, h - 12);

          // --- VI·ªÄN ---
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, w, h);
          // gi·∫£m glow
          grd.addColorStop(0.3, "#66BB6A");
          grd.addColorStop(0.6, "#2E7D32");
          grd.addColorStop(1, "#0B3D1E");

          // vi·ªÅn s√°ng s·∫Øc
          ctx.strokeStyle = "#A5D6A7";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, w, h);
        }

        return new THREE.CanvasTexture(canvas);
      }

      const textures = {
        gold: createCustomTexture("gold_glow"),
        red: createCustomTexture("red_light"),
        gift: createCustomTexture("gift_red"),
        white: createCustomTexture("white_glow"), // ‚úÖ NEW
      };
      textures.green = createCustomTexture("green_glow");

      // ==========================================
      // 2. SYSTEM CONFIG Vandiep
      // ==========================================
      const CONFIG = {
        // ‚úÖ D√ÄY H∆†N + TO H∆†N
        goldCount: 4500,
        redCount: 70,
        whiteCount: 3000, // ‚úÖ NEW depth
        giftCount: 30,
        greenCount: 2000,

        explodeRadius: 65,
        photoOrbitRadius: 25,
        treeHeight: 70,
        treeBaseRadius: 35, // tƒÉng nh·∫π ƒë·ªÉ c√¢y ƒë·∫ßy ƒë·∫∑n h∆°n
      };

      let scene, camera, renderer;
      let groupGold, groupRed, groupGift, groupWhite, groupGreen; // ‚úÖ groupWhite
      let snowGroup; // ‚úÖ snow overlay
      let photoMeshes = [];
      let titleMesh, starMesh, loveMesh;

      let state = "TREE";
      let selectedIndex = 0;
      let handX = 0.5;

      // ==========================================
      // 3. THREE.JS SYSTEM Vandiep
      // ==========================================
      function init3D() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        // scene.fog = new THREE.FogExp2(0x000000, 0.002);
        scene.fog = new THREE.FogExp2(0x000000, 0.0009);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // ‚úÖ size tƒÉng nh·∫π cho gold/red ƒë·ªÉ c√¢y ‚Äúƒë·∫ßy‚Äù h∆°n
        groupGold = createParticleSystem("gold", CONFIG.goldCount, 2.8);
        groupRed = createParticleSystem("red", CONFIG.redCount, 6.5);
        groupGift = createParticleSystem("gift", CONFIG.giftCount, 8.0);
        groupGreen = createParticleSystem("green", CONFIG.greenCount, 4.5);

        // ‚úÖ NEW: white depth layer
        groupWhite = createParticleSystem("white", CONFIG.whiteCount, 2.8);

        createPhotos();
        createDecorations();

        // ‚úÖ NEW: snow overlay
        createSnow();

        animate();
      }

      function createParticleSystem(type, count, size) {
        const pPositions = [];
        const pExplodeTargets = [];
        const pTreeTargets = [];
        const pHeartTargets = [];
        const sizes = [];
        const phases = [];

        for (let i = 0; i < count; i++) {
          // --- TREE ---
          // const h = Math.random() * CONFIG.treeHeight;
          // const y = h - CONFIG.treeHeight / 2;
          let h;

          if (type === "gift") {
            // üéÅ Chia c√¢y th√†nh t·∫ßng
            const layers = 12;
            const layerIndex = Math.floor(Math.random() * layers);

            // ch·ªâ cho qu√† n·∫±m trong 65% d∆∞·ªõi
            const maxGiftHeight = CONFIG.treeHeight * 0.65;
            const layerHeight = maxGiftHeight / layers;

            // m·ªói t·∫ßng random nh·∫π b√™n trong
            h = layerIndex * layerHeight + Math.random() * layerHeight * 0.9;
          } else if (type === "red") {
            // üî¥ tr√°nh ch√≥p
            h = Math.random() * CONFIG.treeHeight * 0.85;
          } else {
            h = Math.random() * CONFIG.treeHeight;
          }

          const y = h - CONFIG.treeHeight / 2;

          // ‚úÖ l√†m c√¢y ‚Äúƒë·∫ßy‚Äù h∆°n:
          // - gold: ph√¢n b·ªë ƒë·ªÅu (sqrt)
          // - red: h∆°i nghi√™ng v·ªÅ outer
          // - white: n·∫±m ‚Äúb√™n trong‚Äù nhi·ªÅu h∆°n ƒë·ªÉ t·∫°o depth
          let radiusRatio;

          if (type === "green") {
            // üü© XANH: √âP V√ÄO L√ïI
            radiusRatio = Math.pow(Math.random(), 2.5); // c√†ng l·ªõn c√†ng v√†o trong
          } else if (type === "gold") {
            // üü° V√ÄNG: PH·ª¶ NGO√ÄI
            radiusRatio = Math.pow(Math.random(), 0.55);
          } else if (type === "white") {
            // ‚ö™ TR·∫ÆNG: s√¢u + n·ªÅn
            radiusRatio = Math.pow(Math.random(), 0.35);
          } else if (type === "red") {
            // üî¥ ƒê·ªé: TR·∫¢I ƒê·ªÄU (KH√îNG L√äN NG·ªåN)
            radiusRatio = 0.4 + Math.random() * 0.75;
          } else if (type === "gift") {
            // Gift: TR·∫¢I ƒê·ªÄU (KH√îNG L√äN NG·ªåN)
            radiusRatio = Math.pow(Math.random(), 0.1);
          } else {
            radiusRatio = Math.random();
          }

          // --- TREE POSITION (REALISTIC ORNAMENT LOGIC) ---

          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
          const r = maxR * radiusRatio;
          const theta = Math.random() * Math.PI * 2;
          pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          // --- EXPLODE ---
          const u = Math.random();
          const v = Math.random();
          const phi = Math.acos(2 * v - 1);
          const lam = 2 * Math.PI * u;
          let radMult = 1.0;

          // üéÅ square bay xa
          if (type === "gift") {
            radMult = 1.3;
          }

          // ‚ö™ white bay XA h∆°n ‚Üí bung m·∫°nh
          else if (type === "white") {
            radMult = 1.8;
          }

          const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
          pExplodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );

          // --- SOFT HEART ---
          const tHeart = Math.random() * Math.PI * 2;
          let hx = 16 * Math.pow(Math.sin(tHeart), 3);
          let hy =
            13 * Math.cos(tHeart) -
            5 * Math.cos(2 * tHeart) -
            2 * Math.cos(3 * tHeart) -
            Math.cos(4 * tHeart);

          const rFill = Math.pow(Math.random(), 0.3);
          hx *= rFill;
          hy *= rFill;
          let hz = (Math.random() - 0.5) * 8 * rFill;

          const noise = 1.0;
          hx += (Math.random() - 0.5) * noise;
          hy += (Math.random() - 0.5) * noise;
          hz += (Math.random() - 0.5) * noise;

          const scaleH = 2.2;
          pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz);

          // --- INIT ---
          pPositions.push(
            pTreeTargets[i * 3],
            pTreeTargets[i * 3 + 1],
            pTreeTargets[i * 3 + 2]
          );
          // sizes.push(size);
          // phases.push(Math.random() * Math.PI * 2);
          // --- INIT ---

          // üéÑ SIZE PATTERN ‚Äì l√†m c√¢y d√†y & c√≥ nh·ªãp
          let finalSize = size;

          if (type === "gold" || type === "red") {
            // To ‚Äì nh·ªè xen k·∫Ω + random nh·∫π
            if (i % 3 === 0) {
              finalSize = size * 1.6; // h·∫°t to
            } else if (i % 3 === 1) {
              finalSize = size * 0.75; // h·∫°t nh·ªè
            } else {
              finalSize = size * 1.1; // trung b√¨nh
            }
            finalSize *= 0.9 + Math.random() * 0.25;
          }

          if (type === "white") {
            // White = nh·ªè, nhi·ªÅu, n·∫±m s√¢u
            finalSize = size * (0.5 + Math.random() * 0.6);
          }

          sizes.push(finalSize);
          phases.push(Math.random() * Math.PI * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(pPositions, 3)
        );
        geo.setAttribute("size", new THREE.Float32BufferAttribute(sizes, 1));

        // colors
        const colors = new Float32Array(count * 3);
        const baseColor = new THREE.Color();
        if (type === "gold") baseColor.setHex(0xffd700);
        else if (type === "red") baseColor.setHex(0xff0000);
        else baseColor.setHex(0xffffff);

        for (let i = 0; i < count; i++) {
          colors[i * 3] = baseColor.r;
          colors[i * 3 + 1] = baseColor.g;
          colors[i * 3 + 2] = baseColor.b;
        }
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        geo.userData = {
          tree: pTreeTargets,
          explode: pExplodeTargets,
          heart: pHeartTargets,
          phases: phases,
          baseColor: baseColor,
          baseSize: size,
        };

        // const mat = new THREE.PointsMaterial({
        //   size: size,
        //   map: textures[type],
        //   transparent: true,
        //   opacity: 1.0,
        //   vertexColors: true,
        //   blending:
        //     type === "gift" ? THREE.NormalBlending : THREE.AdditiveBlending,
        //   depthWrite: false,
        //   sizeAttenuation: true,
        // });
        const mat = new THREE.PointsMaterial({
          size: size,
          map: textures[type],
          transparent: true,

          opacity: type === "white" ? 0.55 : 1.0,
          vertexColors: type === "white",

          blending:
            type === "gold" || type === "white"
              ? THREE.AdditiveBlending
              : THREE.NormalBlending,

          // üî• QUAN TR·ªåNG
          depthWrite: type === "gold" || type === "white" ? false : true,
          depthTest: true,

          sizeAttenuation: true,
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        const borderGeo = new THREE.PlaneGeometry(9, 9);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });

        for (let i = 0; i < 5; i++) {
          const mat = new THREE.MeshBasicMaterial({
            map: photoTextures[i],
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geo, mat);
          const border = new THREE.Mesh(borderGeo, borderMat);
          border.position.z = -0.1;
          mesh.add(border);
          mesh.visible = false;
          mesh.scale.set(0, 0, 0);
          scene.add(mesh);
          photoMeshes.push(mesh);
        }
      }

      function createDecorations() {
        // MERRY CHRISTMAS
        const canvas = document.createElement("canvas");
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");
        ctx.font = 'bold italic 90px "Times New Roman"';
        ctx.fillStyle = "#FFD700";
        ctx.textAlign = "center";
        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 40;
        ctx.fillText("MERRY CHRISTMAS", 512, 130);
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });

        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
        titleMesh.position.set(0, 50, 0);
        scene.add(titleMesh);

        // STAR
        const starCanvas = document.createElement("canvas");
        starCanvas.width = 128;
        starCanvas.height = 128;
        const sCtx = starCanvas.getContext("2d");
        sCtx.fillStyle = "#FFFF00";
        sCtx.shadowColor = "#FFF";
        sCtx.shadowBlur = 20;
        sCtx.beginPath();
        const cx = 64,
          cy = 64,
          outer = 50,
          inner = 20;
        for (let i = 0; i < 5; i++) {
          sCtx.lineTo(
            cx + Math.cos(((18 + i * 72) / 180) * Math.PI) * outer,
            cy - Math.sin(((18 + i * 72) / 180) * Math.PI) * outer
          );
          sCtx.lineTo(
            cx + Math.cos(((54 + i * 72) / 180) * Math.PI) * inner,
            cy - Math.sin(((54 + i * 72) / 180) * Math.PI) * inner
          );
        }
        sCtx.closePath();
        sCtx.fill();
        const starTex = new THREE.CanvasTexture(starCanvas);
        const starMat = new THREE.MeshBasicMaterial({
          map: starTex,
          transparent: true,
          blending: THREE.AdditiveBlending,

          depthTest: false, // üî• kh√¥ng b·ªã che
          depthWrite: false, // üî• lu√¥n n·ªïi
        });

        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), starMat);
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
        scene.add(starMesh);

        // I LOVE YOU
        const loveCanvas = document.createElement("canvas");
        loveCanvas.width = 1024;
        loveCanvas.height = 256;
        const lCtx = loveCanvas.getContext("2d");
        lCtx.font = 'bold 120px "Segoe UI", sans-serif';
        lCtx.fillStyle = "#FF69B4";
        lCtx.textAlign = "center";
        lCtx.shadowColor = "#FF1493";
        lCtx.shadowBlur = 40;
        lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 512, 130);
        const loveTex = new THREE.CanvasTexture(loveCanvas);
        const loveMat = new THREE.MeshBasicMaterial({
          map: loveTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
        loveMesh.position.set(0, 0, 20);
        loveMesh.visible = false;
        scene.add(loveMesh);
      }

      function updateParticleGroup(
        group,
        type,
        targetState,
        speed,
        handRotY,
        time
      ) {
        const positions = group.geometry.attributes.position.array;
        const sizes = group.geometry.attributes.size.array;
        const colors = group.geometry.attributes.color.array;
        const phases = group.geometry.userData.phases;
        const baseColor = group.geometry.userData.baseColor;
        const baseSize = group.geometry.userData.baseSize;

        const targetKey =
          targetState === "TREE"
            ? "tree"
            : targetState === "HEART"
            ? "heart"
            : "explode";
        const targets =
          group.geometry.userData[
            targetState === "PHOTO" ? "explode" : targetKey
          ];

        // Move
        for (let i = 0; i < positions.length; i++) {
          positions[i] += (targets[i] - positions[i]) * speed;
        }
        group.geometry.attributes.position.needsUpdate = true;

        const count = positions.length / 3;

        if (targetState === "TREE") {
          group.rotation.y += 0.003;

          for (let i = 0; i < count; i++) {
            // gi·ªØ nguy√™n size g·ªëc ƒë·ªÉ t·∫°o metallic contrast
            sizes[i] = sizes[i];

            let brightness = 1.0;
            if (type === "red") {
              brightness = 1.0;
            } else if (type === "gold") {
              brightness = 1.0;
              // brightness = 0.8 + 0.4 * Math.sin(time * 10 + phases[i]);
            } else if (type === "white") {
              // ‚úÖ white depth: nh·∫π h∆°n ƒë·ªÉ t·∫°o chi·ªÅu s√¢u
              brightness = 0.55 + 0.25 * Math.sin(time * 6 + phases[i]);
            }

            if (group.material.vertexColors) {
              colors[i * 3] = baseColor.r * brightness;
              colors[i * 3 + 1] = baseColor.g * brightness;
              colors[i * 3 + 2] = baseColor.b * brightness;
            }
          }
          group.geometry.attributes.color.needsUpdate = true;
          group.geometry.attributes.size.needsUpdate = true;
          groupGold.visible = true;
          groupRed.visible = true;
          groupGift.visible = true;
          groupWhite.visible = true;
          groupGreen.visible = true;
        } else if (state === "HEART") {
          titleMesh.visible = false;
          starMesh.visible = false;

          groupWhite.visible = false;
          groupGreen.visible = false;
          groupRed.visible = false;
          groupGift.visible = false;
          loveMesh.visible = true;
          photoMeshes.forEach((m) => (m.visible = false));

          const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
          loveMesh.scale.set(s, s, 1);
        } else {
          group.scale.set(1, 1, 1);
          group.rotation.y += (handRotY - group.rotation.y) * 0.1;

          for (let i = 0; i < count; i++) {
            // sizes[i] = baseSize;

            let brightness = 1.0;
            if (type === "gold" || type === "red" || type === "green") {
              const viewFactor = Math.abs(Math.sin(group.rotation.y));
              brightness = 0.85 + viewFactor * 0.9;
            } else if (type === "white") {
              brightness = 0.6 + 0.3 * Math.sin(time * 10 + phases[i]);
            }

            colors[i * 3] = baseColor.r * brightness;
            colors[i * 3 + 1] = baseColor.g * brightness;
            colors[i * 3 + 2] = baseColor.b * brightness;
          }
          group.geometry.attributes.size.needsUpdate = true;
          group.geometry.attributes.color.needsUpdate = true;
          groupGold.visible = true;
          groupRed.visible = true;
          groupGift.visible = true;
          groupWhite.visible = true;
          groupGreen.visible = true;
        }
      }

      // ‚úÖ NEW: Snow overlay (fine snow)
      function createSnow() {
        const count = 1800;
        const pos = [];
        const vel = [];

        for (let i = 0; i < count; i++) {
          pos.push(
            (Math.random() - 0.5) * 220,
            Math.random() * 140 - 10,
            (Math.random() - 0.5) * 220
          );
          vel.push(0.06 + Math.random() * 0.14); // fall speed per flake
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
        geo.userData = { vel };

        const mat = new THREE.PointsMaterial({
          size: 1.15,
          map: textures.white,
          transparent: true,
          opacity: 0.35,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: true,
        });

        snowGroup = new THREE.Points(geo, mat);
        snowGroup.renderOrder = 999; // keep on top-ish
        scene.add(snowGroup);
      }

      function updateSnow(time) {
        if (!snowGroup) return;
        const p = snowGroup.geometry.attributes.position.array;
        const vel = snowGroup.geometry.userData.vel;

        for (let i = 0; i < p.length; i += 3) {
          const idx = i / 3;

          // gentle drift
          p[i] += Math.sin(time * 0.6 + idx) * 0.002;
          p[i + 2] += Math.cos(time * 0.6 + idx) * 0.002;

          // fall
          p[i + 1] -= vel[idx];

          if (p[i + 1] < -55) {
            p[i + 1] = 85;
            p[i] = (Math.random() - 0.5) * 220;
            p[i + 2] = (Math.random() - 0.5) * 220;
          }
        }
        snowGroup.geometry.attributes.position.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const speed = 0.08;
        const handRotY = (handX - 0.5) * 4.0;
        groupGold.material.rotation = groupGold.rotation.y * 1.2;
        groupRed.material.rotation = groupRed.rotation.y * 1.2;
        groupGreen.material.rotation = groupGreen.rotation.y * 1.2;

        updateParticleGroup(groupGold, "gold", state, speed, handRotY, time);
        updateParticleGroup(groupRed, "red", state, speed, handRotY, time);
        updateParticleGroup(groupGift, "gift", state, speed, handRotY, time);
        updateParticleGroup(groupWhite, "white", state, speed, handRotY, time); // ‚úÖ NEW
        updateParticleGroup(groupGreen, "green", state, speed, handRotY, time);

        photoMeshes.forEach((mesh, i) => {
          if (!mesh.material.map && photoTextures[i]) {
            mesh.material.map = photoTextures[i];
            mesh.material.needsUpdate = true;
          }
        });

        if (state === "TREE") {
          titleMesh.visible = true;
          starMesh.visible = true;
          loveMesh.visible = false;
          titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
          starMesh.rotation.z -= 0.02;
          starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);
          photoMeshes.forEach((m) => {
            m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            m.visible = false;
          });
        } else if (state === "HEART") {
          // UI
          titleMesh.visible = false;
          starMesh.visible = false;
          loveMesh.visible = true;

          // ‚ù§Ô∏è CH·ªà GI·ªÆ PARTICLE T·∫†O TR√ÅI TIM
          groupGold.visible = false;

          groupWhite.visible = true;

          // ‚ùå ·∫®N NH·ªÆNG TH·ª® KH√îNG LI√äN QUAN
          groupGift.visible = false; // üéÅ kh√¥ng t·∫°o tim
          groupGreen.visible = false; // üå≤ kh√¥ng l·ªô c√¢y
          groupRed.visible = false;
          photoMeshes.forEach((m) => (m.visible = false));

          // ƒê·∫©y ch·ªØ ra ph√≠a tr∆∞·ªõc
          loveMesh.position.z = 30;

          // Nh·ªãp tim
          const s = 1 + Math.abs(Math.sin(time * 3)) * 0.12;
          loveMesh.scale.set(s, s, 1);
        } else if (state === "EXPLODE") {
          titleMesh.visible = false;
          starMesh.visible = false;
          loveMesh.visible = false;
          const baseAngle = groupGold.rotation.y;
          const angleStep = (Math.PI * 2) / 5;
          let bestIdx = 0;
          let maxZ = -999;

          photoMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = baseAngle + i * angleStep;
            const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
            const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
            const y = Math.sin(time + i) * 3;
            mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            mesh.lookAt(camera.position);
            if (z > maxZ) {
              maxZ = z;
              bestIdx = i;
            }
            if (z > 5) {
              const ds = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
              mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
            } else {
              mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
            }
          });
          selectedIndex = bestIdx;
        } else if (state === "PHOTO") {
          loveMesh.visible = false;
          photoMeshes.forEach((mesh, i) => {
            if (i === selectedIndex) {
              mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
              mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
              mesh.lookAt(camera.position);
              mesh.rotation.z = 0;
            } else {
              mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
          });
        }

        // ‚úÖ snow overlay update
        updateSnow(time);

        renderer.render(scene, camera);
      }

      function startSystem() {
        document.getElementById("btnStart").style.display = "none";
        bgMusic.play().catch((e) => console.log(e));
        init3D();

        const video = document.getElementsByClassName("input_video")[0];
        const canvas = document.getElementById("camera-preview");
        const ctx = canvas.getContext("2d");

        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        hands.onResults((results) => {
          ctx.clearRect(0, 0, 100, 75);
          ctx.drawImage(results.image, 0, 0, 100, 75);

          // --- Hand Logic ---
          if (results.multiHandLandmarks.length === 2) {
            const h1 = results.multiHandLandmarks[0];
            const h2 = results.multiHandLandmarks[1];
            const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
            const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
            if (distIndex < 0.15 && distThumb < 0.15) {
              state = "HEART";
              return;
            }
          }

          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            handX = lm[9].x;
            const tips = [8, 12, 16, 20];
            const wrist = lm[0];
            let openDist = 0;
            tips.forEach(
              (i) =>
                (openDist += Math.hypot(lm[i].x - wrist.x, lm[i].y - wrist.y))
            );
            const avgDist = openDist / 4;
            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

            if (avgDist < 0.25) {
              state = "TREE";
            } else if (pinchDist < 0.05) {
              state = "PHOTO";
            } else {
              state = "EXPLODE";
            }
          } else {
            state = "TREE";
          }
        });

        const cameraUtils = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 320,
          height: 240,
        });
        cameraUtils.start();
      }

      window.addEventListener("resize", () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
